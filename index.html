<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Steady AR Navigation</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">

<style>
    /* --- RESET & LAYOUT --- */
    body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #000; }

    /* 1. BACKGROUND CAMERA */
    #camera-feed {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        object-fit: cover; z-index: -1;
    }

    /* 2. UI LAYER (HUD) */
    #ui-layer {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; pointer-events: none;
    }

    /* Distance Badge */
    .info-badge {
        margin-top: 40px; align-self: center;
        background: rgba(10, 10, 10, 0.9); color: #fff;
        padding: 15px 35px; border-radius: 50px;
        text-align: center; border: 1px solid rgba(255,255,255,0.2);
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 25px rgba(0,0,0,0.6);
        pointer-events: auto;
    }
    #dist-text { font-size: 42px; font-weight: 800; letter-spacing: -1px; }
    #status-text { font-size: 12px; color: #ccc; text-transform: uppercase; letter-spacing: 1.5px; margin-top: 5px; }

    /* The AR Arrow */
    #arrow-container {
        flex-grow: 1; display: flex;
        align-items: center; justify-content: center;
        perspective: 1000px;
    }
    #arrow-img {
        width: 180px; height: 180px;
        background-image: url("https://cdn-icons-png.flaticon.com/512/724/724927.png");
        background-size: contain; background-repeat: no-repeat;
        /* Cyan Glow for Visibility */
        filter: drop-shadow(0 0 25px #00e5ff); 
        /* Smoother transition for less jitter */
        transition: transform 0.2s cubic-bezier(0.1, 0.5, 0.5, 1);
    }

    /* Mini Map (UPDATED: BIGGER SIZE) */
    #mini-map-container {
        position: absolute; bottom: 30px; right: 20px;
        width: 200px; height: 200px; /* Increased from 140px */
        border-radius: 30px; /* Soft square looks better at this size */
        overflow: hidden;
        border: 4px solid rgba(255,255,255,0.9);
        box-shadow: 0 15px 40px rgba(0,0,0,0.7);
        pointer-events: auto; background: #1a1a1a;
    }
    #map { width: 100%; height: 100%; }

    /* Start Button */
    #start-btn {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px 50px; font-size: 20px; font-weight: bold;
        background: linear-gradient(135deg, #007cbf, #00bfa5);
        color: white; border: none; border-radius: 60px;
        cursor: pointer; z-index: 100;
        box-shadow: 0 10px 50px rgba(0, 124, 191, 0.6);
    }
</style>
</head>

<body>

    <video id="camera-feed" autoplay playsinline muted></video>

    <div id="ui-layer">
        <div class="info-badge">
            <div id="dist-text">--</div>
            <div id="status-text">Initialize</div>
        </div>
        <div id="arrow-container">
            <div id="arrow-img"></div>
        </div>
        <div id="mini-map-container">
            <div id="map"></div>
        </div>
    </div>

    <button id="start-btn" onclick="startSystem()">START AR</button>

    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>

<script>
    /* ================= 1. CONFIGURATION ================= */
    
    //  PASTE YOUR MAPBOX TOKEN HERE
    const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGVtYW50aDg1MDMiLCJhIjoiY21rNzV5c2w2MHlqeTNncjI5bjkyeWJwaiJ9.NnunzAB_24Ntn83H5hRcyQ'; 

    //  SET DESTINATION (Lat, Lng)
    // Example: VIT Vellore Main Gate
    const DESTINATION = { lat: 12.9692, lng: 79.1559 }; 

    //  SETTINGS (UPDATED FOR STABILITY)
    const NODE_SWITCH_DIST = 12; // Lowered to 12m for tighter path accuracy
    const SMOOTHING = 0.05;      // Lowered from 0.15 (0.05 = Very smooth/steady arrow)

    /* ================= 2. STATE VARIABLES ================= */
    let map;
    let currentPos = null;
    let routeCoords = [];   
    let nextNodeIndex = 0;
    
    let currentHeading = 0;
    let smoothedHeading = 0;
    let isFetchingRoute = false;

    /* ================= 3. SYSTEM STARTUP ================= */
    async function startSystem() {
        if(MAPBOX_TOKEN.includes('YOUR_MAPBOX')) {
            alert("锔 Error: Please paste your Mapbox Token in the code!");
            return;
        }

        document.getElementById("start-btn").style.display = "none";
        document.getElementById("status-text").innerText = "Aligning Sensors...";

        // A. Camera
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment" } 
            });
            document.getElementById("camera-feed").srcObject = stream;
        } catch(e) {
            alert("Camera Error: " + e.message);
        }

        // B. Map
        initMapbox();

        // C. Compass
        setupCompass();

        // D. GPS
        if(navigator.geolocation) {
            navigator.geolocation.watchPosition(handleLocation, 
                err => console.warn("GPS Error:", err), 
                { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
            );
        } else {
            alert("GPS not supported");
        }
    }

    function initMapbox() {
        mapboxgl.accessToken = MAPBOX_TOKEN;
        map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [79.1559, 12.9692], 
            zoom: 17, // Zoomed in slightly more for clarity
            attributionControl: false
        });
    }

    /* ================= 4. NAVIGATION LOGIC (Verified) ================= */
    
    function handleLocation(pos) {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        currentPos = { lat, lng };

        // 1. Center Mini-Map
        if(map) map.setCenter([lng, lat]);

        // 2. Fetch Route (Only if we don't have one)
        if(routeCoords.length === 0 && !isFetchingRoute) {
            getMapboxRoute(lat, lng);
        } 
        // 3. Update Arrow (If we have a route)
        else if(routeCoords.length > 0) {
            updateGuidance(lat, lng);
        }
    }

    async function getMapboxRoute(startLat, startLng) {
        isFetchingRoute = true;
        document.getElementById("status-text").innerText = "Finding Path...";

        // API Call: Walking Profile
        const url = `https://api.mapbox.com/directions/v5/mapbox/walking/${startLng},${startLat};${DESTINATION.lng},${DESTINATION.lat}?steps=true&geometries=geojson&access_token=${MAPBOX_TOKEN}`;

        try {
            const res = await fetch(url);
            const data = await res.json();
            
            if(data.routes && data.routes.length > 0) {
                // Store the official path coordinates
                routeCoords = data.routes[0].geometry.coordinates; 
                nextNodeIndex = 0;
                
                drawRouteOnMap(routeCoords);
                document.getElementById("status-text").innerText = "Follow Arrow";
            } else {
                document.getElementById("status-text").innerText = "No Route Found";
            }
        } catch(e) {
            console.error(e);
            document.getElementById("status-text").innerText = "Connection Error";
        }
    }

    function drawRouteOnMap(coords) {
        const draw = () => {
            if (map.getSource('route')) {
                map.getSource('route').setData({
                    type: 'Feature', geometry: { type: 'LineString', coordinates: coords }
                });
            } else {
                map.addSource('route', {
                    type: 'geojson',
                    data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } }
                });
                map.addLayer({
                    id: 'route', type: 'line', source: 'route',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 'line-color': '#00e5ff', 'line-width': 6, 'line-opacity': 0.8 }
                });
            }
        };

        if(map.loaded()) draw();
        else map.on('load', draw);
    }

    function updateGuidance(lat, lng) {
        // --- PATH ADHERENCE LOGIC ---
        // 1. Identify the next specific point on the path
        const targetLng = routeCoords[nextNodeIndex][0];
        const targetLat = routeCoords[nextNodeIndex][1];

        // 2. How far are we from this specific point?
        const distToNode = getDistance(lat, lng, targetLat, targetLng);

        // 3. If we are close (12m), graduate to the NEXT point
        // This ensures we follow the line exactly, segment by segment.
        if(distToNode < NODE_SWITCH_DIST && nextNodeIndex < routeCoords.length - 1) {
            nextNodeIndex++;
        }

        // 4. Update UI Distance
        const totalDist = getDistance(lat, lng, DESTINATION.lat, DESTINATION.lng);
        document.getElementById("dist-text").innerText = Math.round(totalDist) + "m";

        // 5. Update Arrow Bearing
        // Recalculate bearing to the (possibly new) target node
        const nextLng = routeCoords[nextNodeIndex][0];
        const nextLat = routeCoords[nextNodeIndex][1];
        const bearing = getBearing(lat, lng, nextLat, nextLng);
        updateArrow(bearing);
    }

    /* ================= 5. SENSORS (COMPASS) ================= */
    
    function setupCompass() {
        if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
            DeviceOrientationEvent.requestPermission().then(r => {
                if(r === "granted") window.addEventListener("deviceorientation", handleOrientation);
            });
        } else {
             if ('ondeviceorientationabsolute' in window) {
                window.addEventListener("deviceorientationabsolute", handleOrientation);
            } else {
                window.addEventListener("deviceorientation", handleOrientation);
            }
        }
    }

    function handleOrientation(e) {
        let heading = 0;
        if (e.webkitCompassHeading) heading = e.webkitCompassHeading; // iOS
        else if (e.alpha !== null) heading = 360 - e.alpha; // Android
        
        // --- SMOOTHING ALGORITHM (Low Pass Filter) ---
        // This makes the arrow less sensitive to hand shaking
        let diff = heading - smoothedHeading;
        while(diff < -180) diff += 360;
        while(diff > 180) diff -= 360;
        
        // Apply the smoothing factor (0.05)
        smoothedHeading += diff * SMOOTHING;
        currentHeading = smoothedHeading;

        // Visual Update
        if(routeCoords.length > 0 && currentPos) {
            const nextLng = routeCoords[nextNodeIndex][0];
            const nextLat = routeCoords[nextNodeIndex][1];
            const bearing = getBearing(currentPos.lat, currentPos.lng, nextLat, nextLng);
            updateArrow(bearing);
        }
    }

    function updateArrow(targetBearing) {
        let rot = targetBearing - currentHeading;
        while (rot < -180) rot += 360;
        while (rot > 180) rot -= 360;
        document.getElementById("arrow-img").style.transform = `rotate(${rot}deg)`;
    }

    /* ================= 6. MATH ================= */
    
    function getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const 1 = lat1 * Math.PI/180, 2 = lat2 * Math.PI/180;
        const  = (lat2-lat1) * Math.PI/180, 位 = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(/2)**2 + Math.cos(1)*Math.cos(2)*Math.sin(位/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function getBearing(lat1, lon1, lat2, lon2) {
        const 1 = lat1 * Math.PI/180, 2 = lat2 * Math.PI/180;
        const 位 = (lon2-lon1) * Math.PI/180;
        const y = Math.sin(位) * Math.cos(2);
        const x = Math.cos(1)*Math.sin(2) - Math.sin(1)*Math.cos(2)*Math.cos(位);
        return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }
</script>
</body>
</html>
